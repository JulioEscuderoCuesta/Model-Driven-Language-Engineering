/*
 * generated by Xtext 2.31.0
 */
package es.unican.ildm.practica3.xtext.serializer;

import com.google.inject.Inject;
import es.unican.ildm.practica3.xtext.services.FactoryGrammarAccess;
import factory.Assembler;
import factory.CandyBall;
import factory.CandyFlat;
import factory.CandyProducer;
import factory.Connection;
import factory.ConveyorBelt;
import factory.Factory;
import factory.FactoryPackage;
import factory.Flattener;
import factory.Lollipop;
import factory.Stick;
import factory.StickProducer;
import factory.Wrapper;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FactorySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FactoryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FactoryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FactoryPackage.ASSEMBLER:
				sequence_Assembler(context, (Assembler) semanticObject); 
				return; 
			case FactoryPackage.CANDY_BALL:
				sequence_CandyBall(context, (CandyBall) semanticObject); 
				return; 
			case FactoryPackage.CANDY_FLAT:
				sequence_CandyFlat(context, (CandyFlat) semanticObject); 
				return; 
			case FactoryPackage.CANDY_PRODUCER:
				sequence_CandyProducer(context, (CandyProducer) semanticObject); 
				return; 
			case FactoryPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case FactoryPackage.CONVEYOR_BELT:
				sequence_ConveyorBelt(context, (ConveyorBelt) semanticObject); 
				return; 
			case FactoryPackage.FACTORY:
				sequence_Factory(context, (Factory) semanticObject); 
				return; 
			case FactoryPackage.FLATTENER:
				sequence_Flattener(context, (Flattener) semanticObject); 
				return; 
			case FactoryPackage.LOLLIPOP:
				sequence_Lollipop(context, (Lollipop) semanticObject); 
				return; 
			case FactoryPackage.STICK:
				sequence_Stick(context, (Stick) semanticObject); 
				return; 
			case FactoryPackage.STICK_PRODUCER:
				sequence_StickProducer(context, (StickProducer) semanticObject); 
				return; 
			case FactoryPackage.WRAPPER:
				sequence_Wrapper(context, (Wrapper) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Assembler
	 *     Assembler returns Assembler
	 *
	 * Constraint:
	 *     (name=EString processingTime=EInt)
	 * </pre>
	 */
	protected void sequence_Assembler(ISerializationContext context, Assembler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssemblerAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssemblerAccess().getProcessingTimeEIntParserRuleCall_4_0(), semanticObject.getProcessingTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns CandyBall
	 *     CandyBall returns CandyBall
	 *
	 * Constraint:
	 *     {CandyBall}
	 * </pre>
	 */
	protected void sequence_CandyBall(ISerializationContext context, CandyBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns CandyFlat
	 *     CandyFlat returns CandyFlat
	 *
	 * Constraint:
	 *     {CandyFlat}
	 * </pre>
	 */
	protected void sequence_CandyFlat(ISerializationContext context, CandyFlat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns CandyProducer
	 *     CandyProducer returns CandyProducer
	 *
	 * Constraint:
	 *     (name=EString processingTime=EInt counter=EInt)
	 * </pre>
	 */
	protected void sequence_CandyProducer(ISerializationContext context, CandyProducer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.PRODUCER__COUNTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.PRODUCER__COUNTER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCandyProducerAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCandyProducerAccess().getProcessingTimeEIntParserRuleCall_4_0(), semanticObject.getProcessingTime());
		feeder.accept(grammarAccess.getCandyProducerAccess().getCounterEIntParserRuleCall_6_0(), semanticObject.getCounter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (source=[Element|ID] target=[Element|ID])
	 * </pre>
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.CONNECTION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.CONNECTION__SOURCE));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.CONNECTION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.CONNECTION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectionAccess().getSourceElementIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FactoryPackage.Literals.CONNECTION__SOURCE, false));
		feeder.accept(grammarAccess.getConnectionAccess().getTargetElementIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FactoryPackage.Literals.CONNECTION__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ConveyorBelt
	 *     ConveyorBelt returns ConveyorBelt
	 *
	 * Constraint:
	 *     (name=EString capacity=EInt (components+=Component components+=Component*)?)
	 * </pre>
	 */
	protected void sequence_ConveyorBelt(ISerializationContext context, ConveyorBelt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Factory returns Factory
	 *
	 * Constraint:
	 *     ((elements+=Element elements+=Element*)? (connections+=Connection connections+=Connection*)?)
	 * </pre>
	 */
	protected void sequence_Factory(ISerializationContext context, Factory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Flattener
	 *     Flattener returns Flattener
	 *
	 * Constraint:
	 *     (name=EString processingTime=EInt)
	 * </pre>
	 */
	protected void sequence_Flattener(ISerializationContext context, Flattener semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlattenerAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFlattenerAccess().getProcessingTimeEIntParserRuleCall_4_0(), semanticObject.getProcessingTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Lollipop
	 *     Lollipop returns Lollipop
	 *
	 * Constraint:
	 *     {Lollipop}
	 * </pre>
	 */
	protected void sequence_Lollipop(ISerializationContext context, Lollipop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns StickProducer
	 *     StickProducer returns StickProducer
	 *
	 * Constraint:
	 *     (name=EString processingTime=EInt counter=EInt)
	 * </pre>
	 */
	protected void sequence_StickProducer(ISerializationContext context, StickProducer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.PRODUCER__COUNTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.PRODUCER__COUNTER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStickProducerAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStickProducerAccess().getProcessingTimeEIntParserRuleCall_4_0(), semanticObject.getProcessingTime());
		feeder.accept(grammarAccess.getStickProducerAccess().getCounterEIntParserRuleCall_6_0(), semanticObject.getCounter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Stick
	 *     Stick returns Stick
	 *
	 * Constraint:
	 *     {Stick}
	 * </pre>
	 */
	protected void sequence_Stick(ISerializationContext context, Stick semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Wrapper
	 *     Wrapper returns Wrapper
	 *
	 * Constraint:
	 *     (name=EString processingTime=EInt)
	 * </pre>
	 */
	protected void sequence_Wrapper(ISerializationContext context, Wrapper semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FactoryPackage.Literals.MACHINE__PROCESSING_TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWrapperAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWrapperAccess().getProcessingTimeEIntParserRuleCall_4_0(), semanticObject.getProcessingTime());
		feeder.finish();
	}
	
	
}
